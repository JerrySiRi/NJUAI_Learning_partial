'''
【有wa的BUG！】
小爱是探险者协会的成员，业余也喜欢做一些地图测绘的活动，上个月，她动身前往神秘的布鲁爱丽丝地区，并绘制了很多平面地图
希望聪明的你能够帮她测算一下地图中最大的森林面积

一张平面测绘地图由0和1组成的二维数组来表示，二维数组保证非空。
其中，0代表测绘地图上该区域为平地地貌，1代表为树木地貌，森林定义为水平方向或竖直方向相邻的树木地貌组成的集团，具体可见下方示例。

请你编写程序，找到最大的森林面积。#【如果没有森林，则返回0。】
输入共一行，为一个二维数组输出一个数，表示最大的森林的面积示例：
图中最大的森林面积为8

输入示例: [[0,0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1,1],[0,1,1,0,0,0,0,1,1],[0,1,0,0,0,0,0,1,1],[0,1,0,0,1,1,1,0,0],[0,0,0,0,1,1,0,0,0]]
输出示例: 8

[[1,1,0],[1,1,0],[0,0,0]]

[[0,0,0,1],[1,0,0,1],[1,1,0,1],[0,1,1,1]]

[[0,0,1,1,1],[1,0,0,0,1],[0,1,0,0,0],[0,0,1,0,0]]

[[1,1,0,0],[1,1,0,0]]
[[1,1,0,0],[1,1,0,0],[1,1,0,0]]
[[1,0,0,1],[1,0,0,1]]
[[1,0,0,1],[0,1,1,0],[0,0,1,0],[0,1,0,1],[1,0,0,1]]#有错误！！！
[[0,1,1,0],[0,0,1,0],[0,0,0,0]]
[[0,0],[0,0]]
'''


option=[[-1,0],[0,1],[1,0],[0,-1]]
def finish(i,j):#搜索！！不管当前位置，只关心它周围的位置！！！#四周全是has\全是0---完成搜索
    global map
    biao=True
    if map[i][j]==0:
        return True
    for k in range(4):
        if 0<=i+option[k][0]<len(map) and 0<=j+option[k][1]<len(map[0]):
            if map[i+option[k][0]][j+option[k][1]]==1 :
                biao=False
                break
    return biao

#递归
#每次传进来当前需要搜索的位置（i,j）
def seeking(i,j):
    global map
    if map[i][j]==0:#不可以开始搜索
        return 0
    if map[i][j]==1 and finish(i,j):#当前位置是1，开始搜索，而且周围位置搜索完毕
        return 1
    else:#当前位置是1，周围没有搜索完毕
        a=0
        if map[i][j] == 1:  # 先从当前位置进行判断（如果是1的话，得给成has！！！）
            map[i][j] = 'has'
            a+=1
        for k in range(4):
            choice=[]
            if 0<=i+option[k][0]<len(map) and 0<=j+option[k][1]<len(map[0]):
                if map[i + option[k][0]][j + option[k][1]] == 1:#下次从这个位置走
                    map[i + option[k][0]][j + option[k][1]]='has'
                    a+=1
                    choice.append((i + option[k][0],j + option[k][1]))
            for m in choice:#现在每次只有一个可以return！应该是多个相加呢！
                a+=seeking(m[0],m[1])
        return a

map=eval(input())#传进来一个地图，每一此都对原地图进行操作！
num=[]
for i in range(0,len(map)):
    for j in range(0,len(map[0])):
        num.append(seeking(i,j))
print(max(num))






'''

[BUG]:
①处理传入的列表！！！要用eval！！！！
②多个返回值要先存在一个地方，之后在统一返回！
③没有考虑当前位置！！！
'''







