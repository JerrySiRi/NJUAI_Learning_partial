import copy
'''
标题：[Python,模拟]
描述：
J. Boxes 取数博弈:
甲乙两人玩一个取数游戏：有一些在一条直线上相邻排列的盒子，每个盒子里都有一张写有数值的牌。
前：
游戏开始之前，甲乙的得分为0，且甲乙已经知道每个盒子中牌的数值。
中：
游戏开始后，甲和乙轮流取盒子，甲先开始。
在每一回合中，玩家可以【从直线两端的两个盒子】中选择一个盒子，将盒子里的牌的数值加到他的得分中。被选择的盒子将被从直线上移除。
后：
全部盒子都被移除时游戏结束。甲乙两人中得分较高的获得游戏的胜利。

请编写程序完成对游戏结果的判断。将甲和乙的得分分别记为x和y，如果两个玩家都选择对自己最优的策略（即使游戏结束时自己拿到的分数最高的策略）
请计算游戏结束时x-y的值。
【不一定某一轮得分是最高的，目标是最终得分是最高的！】
输入是以' '（空格）划分的整数序列，代表一条直线上相邻排列的盒子中的牌的数值, 【盒子数量小于等于5】。输出是x-y的值。

----------------------
例子：
输入：
14 3 80 17

输出：
74

回合过程：
甲选14
乙选17
甲选80
乙选3

甲分数：94
乙分数：20

甲-乙 = 74
----------------------

样例输入：
4 0
样例输出：
4

样例输入：
4 0 9 6
样例输出：
7

样例输入：
-4 4 9 1
样例输出：
0

甲：-4\9
乙：4\1
'''
#先完成4个的吧
a=input().split()
for i in range(0,len(a)):
    a[i]=int(a[i])


#给的盒子的数目大于等于4个，递归
def opt(li):
    if len(li)<=3:
        x=[]
        y=[]
        if len(li) == 1:
            return li[0]
        if len(li) == 2:
            x.append(max(li))
            p=li.copy()
            p.remove(max(p))
            y = p[:]
            return x[0] - y[0]
            # 如果最大的在中间，乙就可以选到
            # 如果最大的不在中间，乙选择第二大的
        if len(li) == 3:  # 甲可以随便选取
            if max(li) == li[1]:
                y.append(li[1])
                p=li.copy()
                p.remove(li[1])
                x = p[:]
                return sum(x) - sum(y)
            elif max(li) != li[1]:
                cimax_list = li.copy()
                cimax_list.remove(max(li))
                y.append(max(cimax_list))
                p=li.copy()
                p.remove(max(cimax_list))
                x = p[:]
                return sum(x) - sum(y)
    else:
        #甲有两种选择，分别进行列表的copy
        j_1=li.copy()
        j_2=li.copy()
        #甲拿走了第一个元素和最后一个元素。可以把问题变化成，子问题是乙先选、甲后选的问题！（返回一个下一次递归（返回乙-甲分数的最大值！）的负值就可以了。）
        #即甲1+甲2-乙分数的最大值就行！！！
        j_1.remove(li[0])
        j_2.remove(li[-1])
        if li[0]-opt(j_1)>=li[-1]-opt(j_2):
            return li[0]-opt(j_1)
        else:
            return li[-1]-opt(j_2)
print(opt(a))
'''

递归思路分析：
1、递归结束条件：
法一：其实只剩下1、2、3张牌的时候是非常容易通过if else来得到结果的。可以把结束条件改成len《=3就可以了
法二：因为子问题的性质都是一样的，所以完全可以把结束条件就给成len==1.（和斗地主博弈的性质不一样）
----斗地主除了顺子之外，剩下的出牌方式不可以简单通过顺子的方式直接递归到只剩下一张牌的情况。
》》考虑每种出牌方式分别递归or采用排列组合的方式让递归结束的情况更加简单！


2、递归思路
本题和汉诺塔问题一毛一样！
甲拿走了第一个元素和最后一个元素。
可以把问题变化成，子问题是乙先选、甲后选的问题！（返回一个下一次递归（返回乙-甲分数的最大值！）的负值就可以了。）
【此时不完全是子问题，但只是子问题的简单变形，可以通过改变形参来做到！】
即甲1+甲2-乙分数的最大值就行！！！
'''













