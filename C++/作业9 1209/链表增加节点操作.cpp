#include <iostream>
using namespace std;
/*
理解：
Node *p=new Node【p是指向Node结构类型的变量，他被赋值为了New node（指向的元素是一个动态变量）】
 
*/
int main()
{
	//操作1：增加节点【链表为空】 
	struct Node
	{
		int content;		//先对节点进行定义（含有一个内容。含有一个指向下一个元素的指针） 
		Node *next;
	 } ;
	 Node *head =NULL;//增加一个头指针**** 
	 Node *p=new Node;//增加一个可以指向下一个新节点的指针 
	 p->content =a;
	 if(head==NULL)
	 {
	 	head=p;		//让头指针指向新增加的结构（*P）所代表的*** 
	 	p->next=NULL;//现在里边只有一个元素，*P所代表的的之后就没有了***（赋值成NULL） 
	 }
	
	//操作2：增加节点表尾 （表不是空的***） step1：*****找到最后一个元素             
	//step2：******在最后一个元素的位置再加一个动态结构类型
	 struct Node
	{
		int content;		//先对节点进行定义（含有一个内容。含有一个指向下一个元素的指针） 
		Node *next;
	 } ;
	 
	 Node *head =NULL;//增加一个头指针**** 
	 ... 
	 Node *p=new Node;//增加一个可以指向下一个新节点的指针 
	 p->content =a;
	
	 //已经增加了许多的节点了 【用操作1，增加了第一个节点+再进行操作2】 
	 Node *q=head;
	 while(q->next==NULL)
	 	q=q->next;//不断检索当前节点的下一个还有没有元素***现在q就指向了最后的节点了**** 
	 			  //现在p指向的还是一个动态结构类型
	 q->next=p;
	 p->next=NULL;
	 
	 
	//操作3：增加节点（表头**）
	
	struct Node
	{
		int content;		//先对节点进行定义（含有一个内容。含有一个指向下一个元素的指针） 
		Node *next;
	 } ;
	 Node *p=new Node;//【要逐渐习惯这样的动态变量表述】
	Node *head....//已经被附上了值了**
	//现在要修改头指针和新的动态变量p的值**
	p->next=head;
	head=p;
	
	//操作4：插入一个节点
	循环的设计*** 
	while(j<i&&q->next!=NULL)
	{
		q=q->next;【保证了节点一直往后面跑】 
		j++; 【保证往后面跑，跑到了第i个节点就停止了】 
	} 
	/*
	简单思路：
	①先通过循环找到这个第i个节点**
	②再插入进去
	**【一般思路：要先从后面入手，在从前面（不然改变了前面的值之后，原来
	              链表后面那个节点就找不到啦***）】 
	*/ 
	
	//操作5：删除一个节点
	/*
	删除头指针：
	①一定要再设定出来一个动态变量p，让他等于原来的p》》让原来头指针还掉
	②让头指针，从原来指向第一个节点指向第二个节点**
	
	删除尾指针：
	***找到最后一个节点和倒数第二个节点**
	***一次循环就能确定两个位置***》》循环到倒数第二个节点，令他等于倒数第二个
	 								  把这个往后再数一个不就是最后一个节点了麻** 
	*/ 
	 
	//操作6：在链表中检索某一个值a
	循环的设计***
	int index=0;//这是为了之后检索到了之后的下标，访问方便 
	for(p=head;p!=NULL;p=p->next)
	{
		index++;
		if(p->content==a)break;
	 } 
	 //两种情况出来** 没有检索到**p==NULL出来的（p指向最后一个） 
	 【理解出现了问题：p->next的含义只是p中的next的是多少】
	 》》p->next !=NULL是倒数第二个节点
	    p->next==NULL是最后一个节点（p中的next指向NULL） 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	return 0;
}
