#include <iostream>
#include <cmath>
using namespace std;
//题目：回文数判断
//题目描述：输入一个int型的整数，判断其是否为回文数。回文数是从左到右读与从右到左读相同。例如： 121,77,3
//都是回文数，-121和 10不是回文数。
/*
方法一：不用数组，多次循环 
int main() 
{
	int i=1,m=10,j,a,b,c=1,g,k,l;   			//一个个取出来个位、百位、千位...
	cin>>a;
	while(a/m!=0)
	{i++;
	m*=10;
	}                                       //第一步：先弄清他是几位数字			 //一共i位数字
	k=a;
	for(j=1;j<=i/2;j++)
	{	l=a%10;						//从右到左第j位数字
		a=(a-l)/10;						
		
		int power=pow(10,i-j);	
		g=(k/power);				//从左到右第j位数字
		k-=g*power;
		
		if(l!=g)
			{cout<<"false";
			return 0;
			}
	}
	cout << "true";
	return 0;
}

方法一总结：
①如何表示除以10的n次方：先给m赋一个初始值为10，之后每次在循环之中往m处乘10！！ 
----更加直观，比pow函数更好理解 
*****②如何debug！：可以在程序的不同位置加上cout<<，看看这段程序之前的位置有没有正常运行，不断缩小错误范围！！
③思维的转变：如何求出从右到左的第j位数字，并且更新数据？陶的想法是1223-（最后一位的数字）再除10，不断循环
			  我的想法是1223-（余数）*自己所在位置的次方，不断循环。
			  计算机的想法是简单的，要多进行思维上的转变哦，多寻找思路，肯定不止自己所想的一种的哦
④清楚性的问题：陶把10的i-j次方赋给了一个power变量，这样就不会在循环中多次出现pow堆积的情况了，
				这样对自己思维的顺畅一定会起到积极作用的呢！！！
⑤巧用return 0：不满足条件直接输出，可比先跳出循环+在进行判断要简单地多呢 
 
 
*/
//回文数判断#include <iostream>
//方法二：数组的方法！ 

int main () 
{
	int n;
	cin>>n;
	if (n<0)
	  {cout<<"false";return 0;} 
	int a=n;
	int i=1,j=0;
	while (a>=10)
	{a=a/10;                           //判断位数的另外一种方法：不用pow，不断除以10.上面是不断乘以10！ 
	 i++;							   //巧用不断赋值的操作，进行数据更新			
	}
	int d[i];						//运用数组啦，从右开始往左取数字 
	while (n!=0)
      for (int b=0;b<i;b++)			//数组下标从0开始，进行一位位的赋值 
         { d[b]=n%10;				//除10取余数就是最后的那一位！！ 
          n=n/10;					//数据更新：之前的方法是减掉余数。现在的方法是直接除10取整 
		 }
	int count=0;
	for (int k=0;k<=i-1;k++)
	{if (d[k]==d[i-1-k])
		count++;
	}
	if (count!=i)
	    cout<<"false"<<endl;
	else
	    cout<<"true"<<endl;
	return 0;
}
