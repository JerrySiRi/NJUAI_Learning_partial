'''
实现一个卷积运算：
卷积运算是指从输入矩阵的左上角开始，从输入矩阵上创建一个与模板矩阵（卷积核）同样大小的活动窗口
窗口矩阵元素与模板矩阵元素对应起来相乘再相加，并用计算结果代替窗口中心的值。
然后，活动窗口向右移动一列，并作同样的运算。
以此类推，从左到右、从上到下，即可得到一个新的矩阵即为卷积的结果。这里有更具体的介绍：https://zhuanlan.zhihu.com/p/43738099

请编程实现卷积运算，输入为两个numpy矩阵，M,N，维度分别为mxm和nxn（m>n）。
要求以M为输入矩阵，N为模板矩阵（卷积核）进行卷积操作，输出卷积得到的新矩阵，维度应该为（(m-n+1)x(m-n+1)）。
    现在需要通过两种方式实现卷积运算，并且比对两种方式的效率。
    提示：一种是不改变输入，用for循环来不停移动窗口和模板进行卷积。
         另一种是设法利用各种ufunc的组合，以及numpy针对矩阵计算过程进行了优化的优点，提高卷积操作的计算效率。
'''
#使用for循环来进行卷积操作
#输入的矩阵：[[2,1,0,2,3],[9,5,4,2,0],[2,3,4,5,6],[0,4,4,2,8]]---5*5
#模板：[[-1,0,1],[-1,0,1],[-1,0,1]]---3*3
#法1：for循环不断移动窗口和模板进行卷积
a=[[2,1,0,2,3],[9,5,4,2,0],[2,3,4,5,6],[1,2,3,1,0],[0,4,4,2,8]]
b=[[-1,0,1],[-1,0,1],[-1,0,1]]
c=[[0]*3 for i in range(0,3)]#创建了空的输出矩阵
for i in range(0,3):#卷积的模板“切片”中矩阵左上角的位置，得到的[i][j]是输出矩阵的元素
    for j in range(0,3):#矩阵的切片就是[i:i+2]*[j:j+2]
        mul=0
        for k in range(0,3):#【以下在[i][j]作为左上角的矩阵中开始乘积】
            for l in range(0,3):
                mul+=a[i+k][j+l]*b[k][l]
        c[i][j]=mul
print(c)
#38.1 µs ± 1.13 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
#314 µs ± 18.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
#法2：numpy的方法，尝试使用矩阵切片进行操作
import numpy as np
arr1=np.array(a)
arr2=np.array(b)
arr3=np.arange(9).reshape(3,3)
#创建的3*3的矩阵，其中的元素大小可以代表他的坐标。当前位元素除以3的整数是他的行、除以3所得的余数是他的列》》行列就可以确定了，没有必要使用for循环进行遍历啦！
for i in range(0,3):
    for j in range(0,3):#矩阵切片arr1[i:i+3][j:j+3]
        arr3[i][j]=np.sum(arr1[i:i+3,j:j+3]*arr2)
print(arr3)
#121 µs ± 3.26 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
#1.01 ms ± 47.2 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
